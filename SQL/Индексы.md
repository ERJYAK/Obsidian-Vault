### **Индексы**

Индекс — это объект, который создается для одного или более столбцов в таблицах базы данных с целью повышения производительности, а именно для ускорения поиска и извлечения требуемых данных из базы данных. Он определяет соответствие значения ключа записи (атрибута или группы атрибутов) и местоположения этой записи – КБД (доступ к ключу базы данных). Каждый индекс связан с определенной таблицей, но при этом является внешним по отношению к таблице и обычно хранится отдельно от неё.

Индекс представляет собой структуру, которая хранится на диске и предназначена для столбцов таблицы, а также для объектов типа представления (Views).

Индекс состоит из ключей и ссылок на строки в БД. Ключи обычно представляют собой значения одного или нескольких столбцов, по которым происходит поиск, и они хранятся в оптимизированном порядке, чтобы обеспечить быстрый поиск. Указатель может быть прямым адресом строки в таблице или ссылкой на страницу диска, где хранятся данные. Строки идентифицируются с помощью TID (tuple id), который состоит из номера блока файла и позиции строки внутри блока. Тогда, зная ключ или некоторую информацию о нем, можно быстро прочитать те строки, в которых может находиться интересующая нас информация, не просматривая всю таблицу полностью.

Важно понимать, что индекс, ускоряя доступ к данным, взамен требует определенных затрат на свое поддержание. При любой операции над проиндексированными данными — будь то вставка, удаление или обновление строк таблицы, — индексы, созданные для этой таблицы, должны быть перестроены, причем в рамках той же транзакции. Заметим, что обновление полей таблицы, по которым не создавались индексы, не приводит к перестроению индексов; этот механизм называется HOT (Heap-Only Tuples).

#### Типы индексов 
**Покрывающий индекс** - если индекс содержит всю информацию, нужную для запроса
**Составной индекс** - индекс по нескольким полям, порядок установки полей в индексе **важен**. Обычно используется правило, что индексное сканирование происходит до первого неравенства. 
**Простой индекс**  -индекс по 1 столбцу
**Функциональный индекс** - создается по выражению. оптимизатор будет принимать во внимание такой индекс для условий вида «_индексированное-выражение оператор выражение_». Если вычисление индексируемого выражения — затратная операция, то и обновление индекса будет требовать значительных вычислительных ресурсов.
**Частичный индекс** - строится не для всей таблицы, а только для части строк.
#### Структуры организации индексов

##### **B-tree (сбалансированные деревья)**
Индекс btree, он же B-дерево, пригоден для данных, которые можно отсортировать.
  
Как всегда, индексные записи B-дерева упакованы в страницы. В листовых страницах эти записи содержат индексируемые данные (ключи) и ссылки на строки таблицы (TID-ы); во внутренних страницах каждая запись ссылается на дочернюю страницу индекса и содержит минимальное значение ключа в этой странице.

- Они сбалансированы, то есть любую листовую страницу отделяет от корня одно и то же число внутренних страниц. Поэтому поиск любого значения занимает одинаковое время.  
    
- Они сильно ветвисты, то есть каждая страница (как правило, 8 КБ) содержит сразу много (сотни) TID-ов. За счет этого глубина B-деревьев получается небольшой; на практике до 4–5 для очень больших таблиц.  
    
- Данные в индексе упорядочены, а страницы одного уровня связаны между собой двунаправленным списком. Поэтому получить упорядоченный набор данных мы можем, просто проходя по списку в одну или в другую сторону, не возвращаясь каждый раз к корню.

Индекс хорошо подходит для поиска по неравенству. Сложности возникают при составных индексах, так как данные сортируются в указанном строго порядке, из-за этого, порядок после второго начинает работать хуже. Из этой схемы понятно, что поиск будет работать эффективно с такими, например, предикатами, как «class = 3» (поиск только по первому полю) или «class = 3 and model = 'Boeing 777-300'» (поиск по обоим полям).  
  
А вот поиск по предикату «model = 'Boeing 777-300'» будет куда менее эффективным: начиная с корня, мы не можем определить, в какой из дочерних узлов спускаться, поэтому спускаться придется во все.

Метод доступа btree индексирует неопределенные значения и поддерживает поиск по условиям is null и is not null.
##### **Hash**
Идея хеширования состоит в том, чтобы значению любого типа данных сопоставить некоторое небольшое число (от 0 до N−1, всего N значений). Такое сопоставление называют _хеш-функцией._ Полученное число можно использовать как индекс обычного массива, куда и складывать ссылки на строки таблицы (TID). Элементы такого массива называют _корзинами хеш-таблицы_ — в одной корзине могут лежать несколько TID-ов, если одно и то же проиндексированное значение встречается в разных строках.  
  
Хеш-функция тем лучше, чем равномернее она распределяет исходные значения по корзинам. Но даже хорошая функция будет иногда давать одинаковый результат для разных входных значений — это называется _коллизией._ Так что в одной корзине могут оказаться TID-ы, соответствующие разным ключам, и поэтому полученные из индекса TID-ы необходимо перепроверять.

При вставке в индекс вычислим хеш-функцию для ключа. Число корзин изначально равно двум и увеличивается динамически, подстраиваясь под объем данных; номер корзины можно вычислить по хеш-коду с помощью битовой арифметики. В эту корзину и положим наш TID.  
  
Но этого недостаточно, ведь в одну корзину могут попасть TID-ы, соответствующие разным ключам. Так что для экономии места в корзине сохраняется не сам ключ, а его хеш-код.  
  
При поиске в индексе мы вычисляем хеш-функцию для ключа и получаем номер корзины. Остается перебрать все содержимое корзины и вернуть только подходящие TID-ы с нужными хеш-кодами. Это делается эффективно, поскольку пары «хеш-код — TID» хранятся упорядоченно.  
  
Но может так получиться, что два разных ключа не просто попадут в одну корзину, но и будут иметь одинаковые 4-байтовые хеш-коды — коллизии никто не отменял. Поэтому метод доступа просит общий механизм индексирования контролировать каждый TID, перепроверяя условие по табличной строке (механизм умеет это делать заодно с проверкой видимости).

Индексы хранятся на индексных таблицах, которое помещаются в буферный кеш и вытесняются оттуда точно так же, как и табличные страницы.
![[Pasted image 20240728232818.png]]
Хеш-индекс, как видно на картинке, использует страницы (серые прямоугольники) четырех видов:  
- Метастраница (meta page) — нулевая страница, содержит информацию о том, что находится внутри индекса;
- Страницы корзин (bucket page) — основные страницы индекса, хранят данные в виде пар «хеш-код — TID»;
- Страницы переполнения (overflow page) — устроены так же, как страницы корзин, и используются в случае, когда одной страницы для корзины не хватает;
- Страницы битовой карты (bitmap page) — в них отмечаются освободившиеся страницы переполнения, которые можно использовать для других корзин.
Заметим, что хеш-индекс не умеет уменьшаться в размере. Если удалить часть проиндексированных строк, однажды выделенные страницы уже не возвращаются операционной системе, а только переиспользуются для новых данных после очистки (VACUUM). Единственный вариант уменьшить физический размер индекса — перестроить его с нуля командой REINDEX или VACUUM FULL.

**Хеш-индексы идеально подходят для обработки запросов с операторами равенства**.
Соответственно хеш-индекс не может выдавать упорядоченные данные (can_order, orderable). По той же причине хеш-индекс не работает с неопределенными значениями: операция «равно» не имеет смысла для null (search_nulls).  
  
Поскольку в хеш-индексе не сохраняются ключи (а только хеш-коды ключей), он не может использоваться для исключительно индексного доступа (returnable).  
  
Многоколоночные индексы (can_multi_col) этот метод доступа не поддерживает.

##### **GIST (generalized search tree)**
В чем же разница? Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки…  
  
Тут на помощь и приходит индексный метод GiST. Он позволяет задать принцип распределения данных произвольного типа по сбалансированному дереву, и метод использования этого представления для доступа по некоторому оператору. 

GiST — сбалансированное по высоте дерево, состоящее из узлов-страниц. Узлы состоят из индексных записей.  В классическом представлении это R-дерево.
Идея R-дерева состоит в том, что плоскость разбивается на прямоугольники, которые в сумме покрывают все индексируемые точки. Индексная запись хранит прямоугольник, а предикат можно сформулировать так: «искомая точка лежит внутри данного прямоугольника».  
  
Корень R-дерева будет содержать несколько самых крупных прямоугольников (возможно, даже пересекающихся). Дочерние узлы будут содержать меньшие по размеру прямоугольники, вложенные в родительский, в совокупности охватывающие все нижележащие точки.  
  
Листовые узлы, по идее, должны содержать индексируемые точки, однако тип данных во всех индексных записях должен совпадать; поэтому хранятся все те же прямоугольники, но «схлопнутые» до точек.
  
Каждая запись листового узла (листовая запись) содержит, если говорить в самом общем виде, некий _предикат_ (логическое выражение) и ссылку на строку таблицы (TID). Индексированные данные (ключ) должны удовлетворять этому предикату.  
  
Каждая запись внутреннего узла (внутренняя запись) также содержит _предикат_ и ссылку на дочерний узел, причем все индексированные данные дочернего поддерева должны удовлетворять этому предикату. Иными словами, предикат внутренней записи _включает_ в себя предикаты всех дочерних записей. Это важное свойство, заменяющее индексу GiST простую упорядоченность B-дерева.  
  
Поиск в дереве GiST использует специальную _функцию согласованности_ (consistent) — одну из функций, определяемых интерфейсом, и реализуемую по-своему для каждого поддерживаемого семейства операторов.  
  
Функция согласованности вызывается для индексной записи и определяет, «согласуется» ли предикат данной записи с поисковым условием (вида «_индексированное-поле оператор выражение_»). Для внутренней записи она фактически определяет, надо ли спускаться в соответствующее поддерево, а для листовой записи — удовлетворяют ли индексированные данные условию.  

- Корень имеет не менее двух дочерних элементов, если только он не является листом.
- Все листья появляются на одном уровне

Поиск, как обычно в дереве, начинается с корневого узла. С помощью функции согласованности выясняется, в какие дочерние узлы имеет смысл заходить (их может оказаться несколько), а в какие — нет. Затем алгоритм повторяется для каждого из найденных дочерних узлов. Если же узел является листовым, то запись, отобранная функцией согласованности, возвращается в качестве одного из результатов.  
  
Поиск производится в глубину: алгоритм в первую очередь старается добраться до какого-нибудь листового узла. Это позволяет по возможности быстро вернуть первые результаты (что может быть важно, если пользователя интересуют не все результаты, а только несколько).

  
Операторы, рассмотренные до сих пор (такие, как `<@` в предикате `p <@ box '(2,1),(7,4)')`, можно назвать поисковыми, так как они задают **условия поиска** в запросе.  
  
Есть и другой тип операторов — **упорядочивающие**. Они используются для указания порядка выдаваемых результатов во фразе order by там, где обычно применяется простое указание полей. Вот пример такого запроса:  
  
`postgres=# select * from points order by p <-> point '(4,7)' limit 2;`
Здесь `p <-> point '(4,7)'` — выражение, использующее упорядочивающий оператор `<->`, который обозначает расстояние от одного аргумента до другого. Смысл запроса: выдать две точки, ближайшие к точке (4,7). Такой поиск известен как k-NN — k-nearest neighbor search.  
  
Для поддержки такого вида запросов метода доступа должен определить дополнительную _функцию расстояния_ (distance), а упорядочивающий оператор должен быть включен в соответствующий класс операторов (например, для точек — класс points_ops).
##### Про полнотекстовый поиск
  
Документ для целей поиска приводится к специальному типу tsvector, который содержит _лексемы_ и их позиции в документе. Лексемы — это слова, преобразованные к виду, удобному для поиска.
Поисковый запрос представляется другим типом — tsquery. Запрос, грубо говоря, состоит из одной или нескольких лексем, соединенных логическими связками: «и» `&`, «или» `|`, «не» `!`. Также можно использовать скобки для уточнения приоритета операций.

Чтобы полнотекстовый поиск работал быстро, нужно, во-первых, хранить в таблице столбец типа tsvector (чтобы не выполнять дорогое преобразование каждый раз при поиске), и во-вторых, построить по этому полю индекс.
RD-дерево (RD — это Russian Doll, матрешка). Под множеством в данном случае мы понимаем множество лексем документа, но вообще множество может быть любым.
Идея RD-деревьев в том, чтобы вместо ограничивающего прямоугольника взять ограничивающее множество — то есть множество, содержащее все элементы дочерних множеств.  
Такое представление иногда используется, но для других типов данных. А для полнотекстового поиска применяется другое, более компактное, решение — так называемое  _сигнатурное дерево_
  
Каждую лексему можно представить своей _сигнатурой:_ битовой строкой определенной длины, в которой все биты нулевые, кроме одного. Номер этого бита определяется значением хеш-функции от лексемы. _Сигнатурой документа_ называется побитовое «или» сигнатур всех лексем документа.

### Физические соединения

#### Nested Loops Join
**Nested Loops Join** (Вложенные циклы соединения) — это метод выполнения соединения двух таблиц в базе данных, который работает на принципе перебора каждой строки одной таблицы и сравнения её с каждой строкой другой таблицы для нахождения совпадающих пар. Этот метод часто используется в реляционных системах управления базами данных (СУБД).

##### Как устроен Nested Loops Join

1. **Выбор внешней и внутренней таблицы**: Сначала определяется, какая из таблиц будет внешней, а какая — внутренней. Обычно внешней таблицей становится та, что меньше по размеру или по которой проще итерировать.
    
2. **Перебор строк внешней таблицы**: Для каждой строки внешней таблицы...
    
3. **Поиск совпадений во внутренней таблице**: ...происходит перебор всех строк внутренней таблицы. Для каждой пары строк из внешней и внутренней таблиц проверяется условие соединения (например, равенство определённых столбцов).
    
4. **Возврат результата**: Если условие соединения удовлетворяется, то комбинация строк (или нужные поля из них) добавляется в результат.
    

##### Когда применяется

Nested Loops Join часто применяется:

- Когда одна или обе таблицы слишком малы, чтобы использование более сложных алгоритмов соединения было оправдано.
- Когда доступны индексы, которые могут быть использованы для ускорения проверки условий соединения на внутренней таблице.
- В запросах, где фильтрация сильно сокращает число строк до того, как происходит соединение, делая перебор менее затратным.

##### Преимущества

- **Простота реализации**: Алгоритм является простым в реализации и может быть эффективным на маленьких наборах данных или когда есть хорошие индексы.
- **Эффективен на малых данных**: Очень хорошо работает, когда одна из таблиц мала, и особенно если для внутренней таблицы доступен индекс по соединяемому столбцу.

##### Недостатки

- **Масштабируемость**: Метод может быть очень неэффективным на больших данных, так как каждая строка одной таблицы сравнивается с каждой строкой другой таблицы, что может привести к огромному количеству сравнений.
- **Высокая вычислительная стоимость**: В худших случаях производительность может ухудшаться квадратично с увеличением размера данных.

#### Hash Join
**Hash Join** — это техника выполнения соединения таблиц в базах данных, использующая хеш-таблицы для эффективного нахождения совпадений между двумя наборами данных. Этот метод особенно эффективен при обработке больших объёмов данных и широко используется в современных СУБД.


#####  Hash Join

1. **Выбор внутренней и внешней таблицы**: Перед началом выполнения Hash Join одна из таблиц определяется как внутренняя (обычно меньшая), а другая как внешняя.
    
2. **Построение хеш-таблицы**: Для внутренней таблицы строится хеш-таблица, где ключами являются значения столбцов, по которым происходит соединение.
    
3. **Сканирование внешней таблицы**: После построения хеш-таблицы система приступает к сканированию внешней таблицы. Для каждой строки внешней таблицы вычисляется хеш ключа соединения и проверяется наличие соответствующего ключа в хеш-таблице.
    
4. **Возврат совпадающих строк**: Если в хеш-таблице найден ключ, соответствующий текущей строке внешней таблицы, строки комбинируются и добавляются в результат.
    

##### Когда применяется

Hash Join часто используется:

- В запросах соединения больших таблиц, где другие методы соединения (например, Nested Loops) могут быть неэффективны.
- Когда нет индексов, поддерживающих соединение, или когда индексы не могут быть эффективно использованы.
- В распределённых и параллельных системах обработки запросов, где Hash Join позволяет эффективно разделить обработку данных между узлами.

##### Преимущества

- **Высокая производительность**: Hash Join может обрабатывать большие объемы данных быстрее, чем Nested Loops Join, особенно если нет подходящих индексов.
- **Эффективное использование памяти**: Эффективное использование хеш-таблиц позволяет минимизировать обращения к диску.
- **Масштабируемость**: Хорошо подходит для параллельной обработки, что делает его идеальным для больших и распределённых баз данных.

##### Недостатки

- **Требования к памяти**: Построение хеш-таблицы требует достаточного количества оперативной памяти, что может стать проблемой при обработке очень больших таблиц.
- **Ограничения использования**: Неэффективен для диапазонных запросов соединения, так как работает только с условиями равенства.
- **Перерасход памяти**: При недостаточной памяти для хеш-таблицы производительность может сильно упасть из-за необходимости обращения к внешней памяти.

#### Merge Join
**Merge Join** — это техника соединения двух таблиц в базах данных, которая основывается на предварительной сортировке таблиц по ключам соединения. Этот метод часто используется, когда обе таблицы уже отсортированы по соответствующему ключу или могут быть эффективно отсортированы перед выполнением соединения.

##### Как устроен Merge Join

1. **Подготовка таблиц**: Обе таблицы должны быть отсортированы по ключу соединения. Если таблицы изначально не отсортированы, они сортируются перед соединением.
    
2. **Инициализация указателей**: Для каждой таблицы устанавливается указатель на начало.
    
3. **Сравнение ключей и перемещение указателей**: Сравниваются текущие строки из каждой таблицы по ключу соединения. Если ключи совпадают, строки объединяются и добавляются в результат. Указатели обеих таблиц перемещаются вперёд. Если ключ одной таблицы меньше ключа другой, указатель этой таблицы перемещается вперёд, пока ключи не выровняются или не будет достигнут конец таблицы.
    
4. **Процесс продолжается до конца таблиц**: Процесс продолжается до тех пор, пока не будет достигнут конец одной из таблиц.
    

##### Когда применяется

Merge Join часто используется:

- Когда обе таблицы большие, но уже отсортированы по ключу соединения.
- В системах, где затраты на сортировку таблиц невелики или сортировка может быть эффективно выполнена как часть предварительной обработки.
- Для выполнения диапазонных и равенственных соединений, так как этот метод эффективно обрабатывает оба типа условий.

##### Преимущества

- **Эффективность**: Очень эффективен, если таблицы уже отсортированы, так как соединение может быть выполнено в один проход с минимальными затратами на доступ к данным.
- **Поддержка различных типов соединений**: Подходит не только для соединений по равенству, но и для диапазонных соединений.
- **Детерминированное использование памяти**: Требует мало дополнительной памяти, так как данные обрабатываются последовательно.

##### Недостатки

- **Зависимость от сортировки**: Неэффективен, если обе таблицы не отсортированы, так как предварительная сортировка может быть очень затратной по времени и ресурсам.
- **Затраты на сортировку**: Предварительная сортировка больших таблиц может быть дорогой, особенно если для этого требуется много операций ввода-вывода или дополнительная память.
- **Ограниченная масштабируемость**: Может быть не лучшим выбором для очень больших объемов данных, если не доступна эффективная сортировка.