- _Абстракция_. Моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы.
- _Инкапсуляция_. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций.
- _Наследование_. Возможность создания новых абстракций на основе существующих.
- _Полиморфизм_. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций.

Все классы в C# наследуются от класса **object**.
Класс **object**, следовательно любой класс в C# имеет 4 стандартных метода, которые можно переопределить:
- **ToString()**. Возвращает символьную строку с описанием объекта. Так же этот метод вызывается автоматически при выводе содержимого объекта через *WriteLine()*.
- **GetHashCode()**. Возвращает специальный код. Такой код **должен** быть одинаковый у одинаковых объектов, и в большинстве случаев разный у разных объектов. Чтобы использовать объект как ключ, необходимо переропределить этот метод и метод **Equals()**.
- **Equals()**. Сравнивает значения, находящиеся по переданным ссылкам, а  сравнение через \==\ сравнивает ссылки.
- **GetType()**. Возвращает базовую информацию о объекте (классе)

**static** - в соответствие с наименование в начале имени добавляется *s_*. Классы с таким модификатором инициализируются в памяти сразу. Объект такого класса создать нельзя, а все методы и поля такого класса так же имеют модификатор **static**.
Если в обычном классе имеется **static** поле, то такое поле является общим для всех объектов. 
Если в обычном классе имеется **static** метод, то такой метод не имеет доступа к обычным полям и методам класса, а только к **static**. Так же такой метод нельзя вызвать у объекта класса. 
Класс может содержать:
- **Поля** - аргументы класса.
- **const/readonly**. Const — это константа времени компиляции, а readonly — константа времени выполнения. Константы ограничены базовыми **ValueType**, тогда как **readonly** может быть любым типом и инициализируется при создании экземпляра класса.
- **Событие** - обертка над делегатом, которая позволяет уведомлять вызывающий код о некотором действии.
- **Методы** - функции, ассоциированные с классом. При передаче параметров в него неявно передается *this*.
- **Свойства** - поля или методы с параметрами доступа, которые могут быть выставлены через:
```c#
	public void property { get; set; }
```
- **Конструктор** - имеет имя класса и позволяет создать экземпляр класса.
---
### Модификаторы доступа

- **public** - доступен всем из любой части кода
- **protected** - доступен только классу и его наследникам, но недоступен внешнему коду
- **private** - доступен только внутри класса, недоступен даже наследникам
- **internal** - доступ ограничен текущей сборкой
- **sealed** - исключает наследование
--- ---
Ключевое слово **partial** указывает, что другие части класса, структуры или интерфейса могут быть определены в пространстве имен. Все части должны использовать ключевое слово **partial**. Для формирования окончательного типа все части должны быть доступны во время компиляции. Все части должны иметь одинаковые модификаторы доступа.

Существует несколько ситуаций, когда желательно разделение определения класса.
- При работе над большими проектами распределение класса между различными файлами позволяет нескольким программистам работать с ним одновременно.
- При работе с использованием автоматически создаваемого источника код можно добавлять в класс без повторного создания файла источника. Visual Studio использует этот подход при создании форм Windows Forms, кода оболочки веб-службы и т. д. Можно создать код, который использует эти классы, без необходимости изменения файла, созданного в Visual Studio.
- При использовании генераторов источников для создания дополнительных функциональных возможностей в классе.
--- ---
**abstract** - указывает, что что класс предназначен только для использования в качестве базового класса для других классов и не должен быть создан сам по себе.
--- ---
**virtual** методы класса показывают, что метод может быть переопределен в дочерних классах. Если не указывать **virtual** и переопределить метод в дочернем классе через **new**, что при присваивании дочернего объекта к переменной родительского типа и вызове переопределенного метода, то будет вызван родительский. Если указано **virtual**, то вызовется дочерний метод.
--- ---
**base** - необходимо для наследования конструктора родительского класса. С помощью ключевого слова **base** можно вызвать конструктор любой формы, определяемой в базовом классе, причем выполняться будет лишь тот конструктор, параметры которого соответствуют переданным аргументам.
```C#
class MyClass
    {
        public int x, y, z;

        // Конструктор базового класса
        public MyClass(int x, int y, int z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }

    class ClassA : MyClass
    {
        int point;

        // Конструктор производного класса
        public ClassA(int point, int x, int y, int z)
            : base(x, y, z)
        {
            this.point = point;
        }

        public void Pointer(ClassA obj)
        {
            obj.x *= obj.point;
            obj.y *= obj.point;
            obj.z *= obj.point;
            Console.WriteLine("Новые координаты объекта: {0} {1} {2}", obj.x, obj.y, obj.z);
        }
    }
```

--- ---
### Интерфейс

**Интерфейсы не наследуются, а РЕАЛИЗУЮТСЯ**
С помощью интерфейса определяется поведение, которое в дальнейшем будет реализовано в классе. Все  названия интерфейсов начинаются с `I`.
По умолчанию все методы и свойства имеют модификатор доступа `public`.
```C#
interface IDataProcessor
{
	void ProcessData(bool provider);
	int code { get; set; }
}

class ConsoleDataProcessor : IDataProcessor
{
	public void ProcessData(bool provider)
	{
		Console.WriteLine(provider);
	}
	public int code { get; set; }
}
```

**Важное отличие** от абстрактных классов состоит в том, что интерфейсы поддерживают множественное наследование. Так же в интерфейсе не может быть конструкторов.

В переменную типа интерфейса можно положить любой объект класса наследника этого интерфейса.
```C#
IDataProcessor processor = new ConsoleDataProcessor();
```


