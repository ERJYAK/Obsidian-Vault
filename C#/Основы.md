## 1. Сборщик мусора (Garbage Collector)

Это механизм контроля ресурсов в памяти. В его задачи входит освобождение памяти от неиспользуемых объектов.

### Алгоритм работы сборщика мусора

В C# существуют 3 **поколения** объектов (0, 1, 2). 0 поколение называют _эфемерным_.
При создании объекта в памяти ему присваивается 0 поколение. В определенный момент времени приложение приостанавливает свою работу для сборщика мусора. Он проверяет неиспользуемые объекты и удаляет их, поколение оставшихся объектов увеличивается на 1, то есть 0 -> 1.

Если область памяти с каким-либо поколением заполнилась недостаточно, то GC ее не анализирует. Работа его основывается на 2 предположениях:
- Чем ниже поколение, тем больше вероятность удаления.
	Объекты с 0 поколением (мелкие и непостоянные) часто появляются в оперативной памяти, поэтому GC удаляет их чаще.
- Чем выше поколение объекта, тем вероятнее он останется в памяти.

Чтобы сборщик мусора понял, какие объекты можно удалить а какие нет, между ними выстраиваются связи. Связью может быть ссылка, статические объекты и их атрибуты, локальные переменные исполняющегося метода и т.п. Если у объекта нет связей, то он называется **недостижимым** - такие объекты удаляются.

Стадии сборки состоят из 3 этапов:
1. **Маркировка**. На этом этапе выясняется, какие объекты не стоит собирать GC.
2. **Планирование**. Производятся расчет различных показателей текущего состояния памяти и сбор данных, необходимых на этапе чистки. Благодаря информации, полученной на этом этапе, выносится решение о необходимости _дефрагментации_, там же просчитывается, на сколько необходимо двигать объекты и т.д.
3. **Чистка**. В зависимости от необходимости _дефрагментации_ может производится обновление ссылок и _дефрагментация_ или удаление без перемещений.

В **большой куче** объекты размещаются сразу со 2 поколением. Так как это большие объекты и располагаются в памяти для многократного обращения, поэтому GC обращается туда нечасто. 

**Дефрагментация** - это оптимизация адресного пространства.
	Пусть память полностью забита важными объектами. В определенный момент часть объектов становится ненужной и GC удаляет их. Теперь в память необходимо добавить новый объект и полностью в данный момент он не влезает. Но, если оптимизировать размещение объектов в памяти, то новый объект может быть добавлен в память.

---
## Куча и Стек
### Стек
Стек - это структура данных, организованная по принципу LIFO (последний вошел - первый вышел). Задача стека помнить порядок выполнения и хранить **значимые типы данных**.

При каждом вызове метода стек инициализирует _стек-фрейм_ (некий контейнер), где и хранится вся необходимая информация для выполнения методов: параметры, локальные переменные, адреса вызываемых строчек кода.
--- ---
### Куча
Кучу можно представить в виде логистического склада с полками. На полках на разном расстоянии хранятся объекты разных габаритов. К каждому объекту можно получить доступ в любое время.
Расстояние между объектами - это степень фрагментации памяти.

При запуске приложения создаются 2 кучи:
- **Малая куча** - объекты до 85 кб.
- **Большая куча** - объекты свыше 85 кб. Однако, в случае массивов *double* они хранятся в этой куче до достижения размера > 85 кб.

Все ссылочные типы хранятся в куче, однако, ссылка на ссылочные типы хранится в **стеке**.
--- ---
## Делегаты и события

### Делегаты

Делегаты хранят ссылки на методы с одинаковой сигнатурой.

```C#
public delegate WithParameters(int x, bool y);

static void Main()
{
	WithParameters wp = new (ShowParameters);
	wp();
}
public static void ShowParameters(int a, bool b)
{
	Console.WriteLine($"a: {a}, b: {b}");
}
```

**Singlecast** делегат хранит ссылку только на **1** метод.
**Multicast** делегат хранит ссылку на несколько делегатов.

Делегат может иметь ссылку на анонимный метод. Это применятся когда метод применяется однократно и ситуативно:
```C#
public delegate NoParameters();

static void Main()
{
	NoParameters np = delegate ()
	{
		Console.WriteLine("no params");
	};
	np();
}
```

Делегат можно передать в метод в качестве параметров.
Добавление ссылки на метод в делегат происходит под `lock()`, то есть в одном потоке.
К делегату имеется полный доступ как и к любому публичному полю.
### События (event)
Событие это обертка над делегатом.
Событие объявляется в классе. 
```C#
public delegate void Handler(string a);
public event Handler Click;
```

В событие можно только добавить или убрать из него ссылку на метод, даже если это событие публичное. Так же потокобезопасность при таких действиях отсутсвует.
 
--- ---
**Delegate vs Event**

| Delegate                                         | Event                                                   |
| ------------------------------------------------ | ------------------------------------------------------- |
| Функции с возвращаемыми значениями и без         | только `void` функции                                   |
| Может быть вызван извне                          | Вызывать событие может только класс, содержащий событие |
| Не может быть объявлен в интерфейсе              | Может быть объявлен в интерфейсе                        |
| Могут быть переданы в качестве параметров метода |                                                         |
