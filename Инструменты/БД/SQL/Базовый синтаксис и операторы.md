## Операторы выборки данных
### SELECT
**Основное назначение:**  
Оператор SELECT отвечает за выборку столбцов из таблиц или представлений. Он позволяет явно указать, какие поля нужны в результирующем наборе данных.

**Нюансы и хитрости:**

- **Выборка конкретных столбцов vs. SELECT \***  
    Использование конкретных имен столбцов (например, `SELECT id, name`) позволяет избежать избыточной передачи данных и помогает оптимизировать работу с индексами.
- **Алиасы (псевдонимы)**  
    Часто используется синтаксис `AS` для создания псевдонимов столбцов 
	```sql
	SELECT first_name AS Имя
	```
	Это улучшает читаемость запроса, особенно при сложных вычисляемых выражениях или при объединении нескольких таблиц, где имена столбцов могут повторяться.
- **Вычисляемые столбцы и функции**  
    SQL позволяет использовать функции (агрегатные, строковые, математические) прямо в списке столбцов. 
    ```sql
	SELECT UPPER(name) AS Имя_Капсом
	``` 
	или вычисляемые поля, которые можно использовать для дальнейшей сортировки или фильтрации.
- **DISTINCT**  
    Для исключения дублирующих строк можно использовать `SELECT DISTINCT`, что полезно, если требуется получить уникальные значения, но важно понимать, что это может повлиять на производительность при больших объемах данных.

### WHERE
**Основное назначение:**  
Оператор WHERE используется для фильтрации строк на основе заданных условий. Здесь можно применять как простые, так и составные условия с использованием логических операторов.

**Нюансы и хитрости:**

- **Порядок применения условий**  
    Несмотря на то, что SQL не гарантирует порядка применения условий (оптимизатор запросов самостоятельно переставляет их для максимальной эффективности), важно понимать, что использование неиндексированных столбцов или сложных функций может замедлить выполнение запроса.
- **Преобразование типов и функции**  
    Частое применение функций к столбцам 
    ```sql
	WHERE UPPER(name) = 'ИМЯ'
	```
	может препятствовать использованию индексов. Лучше обеспечить, чтобы данные в таблице были приведены к нужному формату или использовать вычисляемые столбцы с индексами.
- **BETWEEN, IN, LIKE и регулярные выражения**  
    Правильный выбор оператора для фильтрации существенно влияет на производительность. Например, `IN` может быть более читаемым, чем множественные условия `OR`, а `LIKE` с ведущим шаблоном (`'%abc'`) зачастую не может использовать индекс.
- **NULL и логика трехзначной логики**  
    Учитывайте, что сравнения с `NULL` требуют специального подхода (`IS NULL` или `IS NOT NULL`), поскольку обычное равенство (`=`) не работает для значений `NULL`.

### ORDER BY
**Основное назначение:**  
Оператор ORDER BY сортирует результирующий набор данных по указанным столбцам.

**Нюансы и хитрости:**

- **Оптимизация сортировки**  
    Сортировка может стать "узким местом" при работе с большими наборами данных. Использование индексов на столбцах, по которым происходит сортировка, может значительно ускорить выполнение запроса.
- **Порядок сортировки**  
    Можно указывать сортировку по возрастанию (`ASC`) или убыванию (`DESC`). При указании нескольких столбцов важно понимать, что сортировка производится в порядке их перечисления.
- **Сортировка по вычисляемым столбцам**  
    Если сортировка осуществляется по вычисляемому столбцу, стоит учитывать влияние на производительность и, возможно, использовать алиасы или подзапросы для оптимизации.
- **Сортировка с учетом COLLATION**  
    В случаях, когда требуется сортировка с учетом региональных настроек или специфических требований к порядку символов, можно указать COLLATE, что особенно актуально для многоязычных баз данных.

 **Ключевые параметры collation**

- **CI (Case Insensitive)** / **CS (Case Sensitive)** — чувствительность к регистру.
    
- **AI (Accent Insensitive)** / **AS (Accent Sensitive)** — игнорирование акцентов (например, `è = e`).
    
- **Кодовая страница** — например, `CP1251` (кириллица), `UTF8` (Unicode).
    

---

 **Примеры популярных collations**

|Collation|Описание|
|---|---|
|`Latin1_General_CI_AS`|Регистронезависимое, учитывает акценты.|
|`SQL_Latin1_General_CP1_CS_AS`|Регистрозависимое, для английского языка.|
|`Ukrainian_CI_AS`|Украинская локализация, регистронезависимое.|
|`UTF8_General_CI_AI`|Unicode, игнорирует регистр и акценты.|
 1. **Создание таблицы с указанием collation**


```sql
CREATE TABLE Users (
    id INT PRIMARY KEY,
    username VARCHAR(50) COLLATE Latin1_General_CI_AS, -- Регистронезависимое сравнение
    email VARCHAR(100) COLLATE SQL_Ukrainian_CP1251_CI_AS -- Украинская локализация
);
```

 2. **Сравнение строк с учетом/без учета регистра**


```sql
-- Регистронезависимое сравнение (CI = Case Insensitive)
SELECT * FROM Products 
WHERE name COLLATE Latin1_General_CI_AI = 'iPhone';

-- Регистрозависимое сравнение (CS = Case Sensitive)
SELECT * FROM Products 
WHERE name COLLATE Latin1_General_CS_AS = 'iPhone';
```


## Операторы модификации данных

### INSERT

- Синтаксис:
    
    ```sql
    INSERT INTO имя_таблицы (столбец1, столбец2, …)  
    VALUES (значение1, значение2, …);
    ```
    
- При указании списка столбцов гарантируется корректное соответствие порядку значений, особенно если таблица содержит автоинкрементные или вычисляемые столбцы.
- Использование множественной вставки:
    
    ```sql
    INSERT INTO имя_таблицы (столбец1, столбец2)  
    VALUES (значение1, значение2), (значение3, значение4), …;
    ```
    
- В ряде СУБД возможен возврат данных вставленных строк (например, оператор OUTPUT в T-SQL или RETURNING в PostgreSQL) для дальнейшей обработки.
- Триггеры: вставка может инициировать триггеры на вставку, поэтому важно учитывать побочные эффекты в бизнес-логике.
### UPDATE

- Синтаксис:
    
    ```sql
    UPDATE имя_таблицы  
    SET столбец1 = новое_значение1, столбец2 = новое_значение2, …  
    WHERE условие;
    ```
    
- Обязательное условие WHERE: отсутствие условия приведёт к обновлению всех записей.
- Возможность обновления с использованием JOIN:
    
    ```sql
    UPDATE t  
    SET t.столбец = значение  
    FROM имя_таблицы t  
    INNER JOIN другая_таблица dt ON t.ключ = dt.ключ  
    WHERE dt.условие;
    ```
    
- Параллельное обновление нескольких столбцов и вычисление новых значений с использованием значений из других столбцов (например, увеличение значения на 1: `SET столбец = столбец + 1`).
- Использование подзапросов в секции SET для вычисления значений, зависящих от данных в других таблицах или агрегатных вычислений.

### DELETE

- Синтаксис:
    
    ```sql
    DELETE FROM имя_таблицы  
    WHERE условие;
    ```
    
- Ключевое требование – наличие условия WHERE: его отсутствие приводит к удалению всех строк таблицы.
- Поддержка конструкции с JOIN в некоторых СУБД для удаления из таблицы на основе условий, заданных в другой таблице:
    
    ```sql
    DELETE t  
    FROM имя_таблицы t  
    INNER JOIN другая_таблица dt ON t.ключ = dt.ключ  
    WHERE dt.условие;
    ```
    
- При наличии внешних ключей с ON DELETE CASCADE удаление записей может вызвать каскадное удаление связанных записей, что требует внимательного проектирования схемы.
- В СУБД с поддержкой возвращаемых данных (например, PostgreSQL с RETURNING) можно получать данные удалённых строк для последующей обработки.

## Группировка и агрегирование

### GROUP BY

Группировка данных для применения агрегатных функций

- **Синтаксис:**
    
    ```sql
    SELECT столбец1, агрегатная_функция(столбец2)
    FROM имя_таблицы
    GROUP BY столбец1;
    ```
    
- **Принцип работы:**  
    Выполняется разбиение выборки на группы по значению одного или нескольких столбцов. Каждая группа содержит строки с идентичными значениями в указанных столбцах. После группировки агрегатные функции (например, `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`) вычисляются для каждой группы отдельно.
- **Обязательные правила:**  
    В запросе, где применяется `GROUP BY`, все столбцы, указанные в списке `SELECT`, должны либо входить в `GROUP BY`, либо использоваться внутри агрегатной функции. Несоблюдение этого правила приводит к ошибке выполнения в большинстве СУБД.
- **Особенности и нюансы:**
    - **NULL как значение:**  
        Строки, где значение группирующего столбца равно NULL, объединяются в одну группу.
    - **Множественная группировка:**  
        Возможна группировка сразу по нескольким столбцам, что позволяет получить более детальное распределение данных:
        
        ```sql
        SELECT столбец1, столбец2, COUNT(*)
        FROM имя_таблицы
        GROUP BY столбец1, столбец2;
        ```
        
    - **Расширенные возможности:**  
        Некоторые СУБД поддерживают конструкции `ROLLUP`, `CUBE` и `GROUPING SETS`, позволяющие получать сводные данные на разных уровнях агрегации. Эти конструкции расширяют стандартный `GROUP BY`, создавая дополнительные итоговые строки на основании различных комбинаций группирующих столбцов.
    - **Оптимизация выполнения:**  
        GROUP BY может быть ресурсоемким на больших наборах данных. Наличие соответствующих индексов на столбцах, используемых в группировке, может существенно повлиять на скорость выполнения запроса.

### HAVING

Фильтрация групп по условиям

- **Синтаксис:**
    
    ```sql
    SELECT столбец1, агрегатная_функция(столбец2)
    FROM имя_таблицы
    GROUP BY столбец1
    HAVING агрегатная_функция(столбец2) условие;
    ```
    
- **Принцип работы:**  
    После того как данные сгруппированы оператором `GROUP BY`, применяется фильтрация групп по условию, заданному в секции `HAVING.` Таким образом, в отличие от `WHERE`, который фильтрует отдельные строки до группировки, `HAVING` фильтрует уже сформированные группы.
- **Особенности и нюансы:**
    - **Использование агрегатных функций:**  
        Условия в `HAVING` обычно содержат агрегатные функции (например, `COUNT`, `SUM`, `AVG`) для фильтрации групп по вычисленным значениям. Например, фильтрация групп, в которых количество записей превышает определённое значение:
        
        ```sql
        HAVING COUNT(*) > 1;
        ```
        
    - **Порядок выполнения:**  
        Первоначально применяется фильтрация строк с помощью `WHERE`, затем выполняется группировка данных, после чего `HAVING` фильтрует сформированные группы. Порядок выполнения критичен для понимания логики обработки данных.
    - **Фильтрация по неагрегированным столбцам:**  
        Теоретически можно использовать неагрегированные столбцы в условии HAVING, если они присутствуют в выражении GROUP BY. Однако такое применение должно соответствовать логике группировки, иначе условие может не иметь смысла или приводить к неоднозначным результатам.
    - **Производительность:**  
        Поскольку HAVING применяется после группировки, фильтрация происходит на уже агрегированном наборе данных. Это может влиять на производительность при обработке больших наборов данных, особенно если условие включает сложные вычисления или несколько агрегатных функций.
    - **Сравнение с WHERE:**  
        WHERE не может содержать агрегатные функции, так как выполняется до группировки. При необходимости фильтрации исходных данных по агрегированным значениям используется HAVING.


### Агрегатные функции

**Агрегатные функции в SQL** используются для вычисления сводных значений по набору строк. Они применяются как к выборкам по всей таблице, так и к отдельным группам, образованным с помощью оператора GROUP BY. Ниже приводится подробное описание основных агрегатных функций с нюансами их применения.

---

#### **COUNT**

- **Основные варианты:**
    - `COUNT(*)` – считает общее количество строк, независимо от наличия NULL-значений в столбцах.
    - `COUNT(столбец)` – считает количество ненулевых значений в указанном столбце.
    - `COUNT(DISTINCT столбец)` – считает количество уникальных ненулевых значений.
- **Нюансы:**
    - Функция `COUNT(*)` быстрее в случаях, когда требуется подсчет строк без анализа конкретных столбцов.
    - При использовании `COUNT(столбец)` строки с NULL-значениями не учитываются, что важно при анализе данных с возможными пропусками.
    - В агрегатных выражениях при группировке (GROUP BY) использование COUNT позволяет оценить количество элементов в каждой группе.

---

#### **SUM**

- **Основные варианты:**
    - `SUM(столбец)` – вычисляет сумму значений числового столбца.
    - `SUM(DISTINCT столбец)` – суммирует уникальные значения.
- **Нюансы:**
    - При отсутствии строк результат SUM возвращает NULL, что может потребовать явного приведения к 0 через функции COALESCE.
    - Тип данных столбца влияет на тип возвращаемого результата. При работе с целыми числами рекомендуется следить за переполнением, особенно если данные большого объема.
    - Если столбец содержит NULL, эти значения не участвуют в суммировании.

---

#### **AVG**

- **Основные варианты:**
    - `AVG(столбец)` – вычисляет среднее арифметическое числовых значений.
    - `AVG(DISTINCT столбец)` – вычисляет среднее значение для уникальных ненулевых значений.
- **Нюансы:**
    - При вычислении среднего важно учитывать типы данных: деление целых чисел может привести к целочисленному результату, поэтому обычно происходит неявное преобразование в тип с плавающей точкой.
    - Если выборка пуста (или все значения NULL), AVG возвращает NULL.
    - При группировке следует помнить, что AVG вычисляется для каждой группы отдельно.

---

#### **MIN и MAX**

- **Основные варианты:**
    - `MIN(столбец)` – возвращает минимальное значение среди ненулевых значений столбца.
    - `MAX(столбец)` – возвращает максимальное значение среди ненулевых значений столбца.
- **Нюансы:**
    - Функции MIN и MAX работают не только с числовыми, но и с текстовыми, датами и другими типами данных, используя определенный порядок сортировки, зависящий от типа данных и настроек колlation.
    - При наличии NULL-значений они игнорируются, за исключением случая, когда все значения NULL – тогда результатом будет NULL.
    - Использование этих функций часто применяется для поиска крайних дат, максимальных или минимальных показателей в выборках.

---

#### **Дополнительные агрегатные функции**

- **GROUP_CONCAT (или STRING_AGG в некоторых СУБД):**
    - Объединяет значения столбца в одну строку с указанным разделителем.
    - Нюанс: порядок значений может быть неопределенным без использования дополнительных параметров сортировки.
- **STDDEV, VARIANCE:**
    - Функции для вычисления стандартного отклонения и дисперсии.
    - Нюансы: доступны не во всех СУБД, тип возвращаемого значения может отличаться.
- **Другие специализированные функции:**
    - В отдельных СУБД могут присутствовать агрегатные функции для работы с XML, JSON или пространственными данными, что требует учета специфики реализации.

---

#### **Общие нюансы агрегатных функций:**

- **Игнорирование NULL:**  
    Все агрегатные функции, кроме COUNT(*), автоматически игнорируют NULL-значения, что важно при обработке неполных данных.
- **Использование с GROUP BY:**  
    При наличии оператора GROUP BY агрегатные функции вычисляются для каждой группы отдельно. В выборке (SELECT) нельзя использовать столбцы, не входящие в GROUP BY, за исключением агрегатных функций.
- **Применение в HAVING:**  
    Для фильтрации групповых данных используется оператор HAVING, где условия могут ссылаться на агрегатные функции. Это позволяет отсеивать группы на основании вычисленных сводных значений.
- **Использование в оконных функциях:**  
    Агрегатные функции могут применяться как оконные функции с использованием конструкции OVER, что позволяет вычислять агрегаты по определенным окнам (например, для расчета скользящего среднего).
- **Производительность:**  
    Выполнение агрегатных функций может потребовать значительных вычислительных ресурсов при работе с большими объемами данных. Наличие индексов и оптимизированная структура запроса способствуют уменьшению времени выполнения.

